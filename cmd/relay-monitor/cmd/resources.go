/*
Copyright Â© 2026 Timothy Drysdale timothy.drysdale@gmail.com

This code was generated by ChatGPT v5.2 14-Jan-2026
*/
package cmd

import (
	"context"
	"log"
	"net/http"
	"os"
	"runtime"
	"strings"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	"github.com/shirou/gopsutil/v4/cpu"
	"github.com/shirou/gopsutil/v4/disk"
	"github.com/shirou/gopsutil/v4/load"
	"github.com/shirou/gopsutil/v4/mem"
	"github.com/spf13/cobra"
)

func getenv(key, def string) string {
	if v := strings.TrimSpace(os.Getenv(key)); v != "" {
		return v
	}
	return def
}

func mustDuration(envKey string, def time.Duration) time.Duration {
	raw := strings.TrimSpace(os.Getenv(envKey))
	if raw == "" {
		return def
	}
	d, err := time.ParseDuration(raw)
	if err != nil {
		log.Fatalf("invalid %s=%q: %v (expected e.g. 5s or 1m)", envKey, raw, err)
	}
	if d <= 0 {
		log.Fatalf("%s must be > 0, got %s", envKey, d)
	}
	return d
}

func hostnameOrUnknown() string {
	h, err := os.Hostname()
	if err != nil || strings.TrimSpace(h) == "" {
		return "unknown"
	}
	return h
}

func parseMountpoints(envVal string) []string {
	parts := strings.Split(envVal, ",")
	out := make([]string, 0, len(parts))
	seen := map[string]struct{}{}
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p == "" {
			continue
		}
		// normalize trailing slash (keep root as "/")
		if len(p) > 1 {
			p = strings.TrimRight(p, "/")
		}
		if _, ok := seen[p]; ok {
			continue
		}
		seen[p] = struct{}{}
		out = append(out, p)
	}
	if len(out) == 0 {
		return []string{"/"}
	}
	return out
}

func clamp(v, lo, hi float64) float64 {
	if v < lo {
		return lo
	}
	if v > hi {
		return hi
	}
	return v
}

// resourcesCmd represents the resources command
var resourcesCmd = &cobra.Command{
	Use:   "resources",
	Short: "A brief description of your command",
	Long: `A longer description that spans multiple lines and likely contains examples
and usage of using your command. For example:

Example: 5-second interval, default mountpoint /
METRICS_INTERVAL=5s LISTEN_ADDR=:9105 ./relay-monitor resources

Example: 1-minute interval, multiple mountpoints
export METRICS_INTERVAL=1m
export MOUNTPOINTS="/,/var/lib/prometheus"
export NODE_NAME="$(hostname -f)"
./relay-monitor resources

Prometheus will automatically set instance="<host>:9105" based on the scrape target. 
Your metrics also include node="<hostname>" as a stable explicit identifier. If you 
prefer to avoid any extra labels, set constLabels := nil and rely solely on instance.

Example prometheus template including this exporter as "hostmetrics"
global:
  scrape_interval: 5s
  scrape_timeout: 5s
  evaluation_interval: 15s

scrape_configs:
  - job_name: "prometheus"
    static_configs:
      - targets: ["127.0.0.1:9090"]

  - job_name: "hostmetrics"
    static_configs:
      - targets: ["127.0.0.1:9105"]

`,
	Run: func(cmd *cobra.Command, args []string) {

		listenAddr := getenv("LISTEN_ADDR", ":9105")
		interval := mustDuration("METRICS_INTERVAL", 5*time.Second)

		nodeName := getenv("NODE_NAME", hostnameOrUnknown())
		mountpoints := parseMountpoints(getenv("MOUNTPOINTS", "/"))

		constLabels := prometheus.Labels{"node": nodeName}
		reg := prometheus.NewRegistry()

		// CPU pressure indicator (load avg; Unix-like)
		cpuLoad1 := prometheus.NewGauge(prometheus.GaugeOpts{
			Name:        "app_cpu_load1",
			Help:        "1-minute system load average.",
			ConstLabels: constLabels,
		})

		// CPU utilization (busy %) across all CPUs
		cpuUsagePct := prometheus.NewGauge(prometheus.GaugeOpts{
			Name:        "app_cpu_usage_percent",
			Help:        "CPU busy percentage across all CPUs [0..100].",
			ConstLabels: constLabels,
		})

		memAvailBytes := prometheus.NewGauge(prometheus.GaugeOpts{
			Name:        "app_mem_available_bytes",
			Help:        "Estimated memory available to start new applications, in bytes.",
			ConstLabels: constLabels,
		})

		diskFreePct := prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Name:        "app_disk_free_percent",
			Help:        "Disk free space as a percentage [0..100].",
			ConstLabels: constLabels,
		}, []string{"mountpoint"})

		reg.MustRegister(cpuLoad1, cpuUsagePct, memAvailBytes, diskFreePct)

		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		// We compute CPU usage as a delta between two samples of CPU time.
		// This stays stable even with a short interval.
		var (
			prevTotal float64
			prevIdle  float64
			havePrev  bool
		)

		updateOnce := func() {
			// Load average (Unix). On Windows, may be unsupported.
			if runtime.GOOS != "windows" {
				if avg, err := load.AvgWithContext(ctx); err == nil {
					cpuLoad1.Set(avg.Load1)
				} else {
					log.Printf("load avg error: %v", err)
				}
			}

			// CPU usage % from cpu.Times (all CPUs aggregated)
			if times, err := cpu.TimesWithContext(ctx, false); err == nil && len(times) == 1 {
				t := times[0]

				// total includes idle + iowait + user + system + ...
				total := t.Total()
				idle := t.Idle
				// On Linux, Idle doesn't include iowait; if you want iowait treated as idle-ish,
				// you can add t.Iowait here. I'm leaving it as "busy" because it represents CPU waiting.
				// idle += t.Iowait

				if havePrev {
					dTotal := total - prevTotal
					dIdle := idle - prevIdle
					if dTotal > 0 {
						busyPct := (1.0 - (dIdle / dTotal)) * 100.0
						cpuUsagePct.Set(clamp(busyPct, 0, 100))
					}
				}
				prevTotal = total
				prevIdle = idle
				havePrev = true
			} else if err != nil {
				log.Printf("cpu times error: %v", err)
			} else {
				log.Printf("cpu times: unexpected result length")
			}

			// Memory available
			if vm, err := mem.VirtualMemoryWithContext(ctx); err == nil {
				memAvailBytes.Set(float64(vm.Available))
			} else {
				log.Printf("mem error: %v", err)
			}

			// Disk free % for each configured mountpoint
			for _, mp := range mountpoints {
				du, err := disk.UsageWithContext(ctx, mp)
				if err != nil {
					log.Printf("disk usage error mountpoint=%q: %v", mp, err)
					continue
				}
				free := 100.0 - du.UsedPercent
				diskFreePct.WithLabelValues(mp).Set(clamp(free, 0, 100))
			}
		}

		go func() {
			t := time.NewTicker(interval)
			defer t.Stop()

			// Prime immediately, then repeat.
			updateOnce()
			for {
				select {
				case <-t.C:
					updateOnce()
				case <-ctx.Done():
					return
				}
			}
		}()

		mux := http.NewServeMux()
		mux.Handle("/metrics", promhttp.HandlerFor(reg, promhttp.HandlerOpts{}))
		mux.HandleFunc("/healthz", func(w http.ResponseWriter, r *http.Request) {
			_, _ = w.Write([]byte("ok\n"))
		})

		srv := &http.Server{
			Addr:              listenAddr,
			Handler:           mux,
			ReadHeaderTimeout: 5 * time.Second,
		}

		log.Printf("starting metrics server on %s interval=%s node=%s mountpoints=%v",
			listenAddr, interval, nodeName, mountpoints)

		log.Fatal(srv.ListenAndServe())

	},
}

func init() {
	rootCmd.AddCommand(resourcesCmd)

	// Here you will define your flags and configuration settings.

	// Cobra supports Persistent Flags which will work for this command
	// and all subcommands, e.g.:
	// resourcesCmd.PersistentFlags().String("foo", "", "A help for foo")

	// Cobra supports local flags which will only run when this command
	// is called directly, e.g.:
	// resourcesCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}
