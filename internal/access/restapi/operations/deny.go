// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
	"net/http"

	"github.com/go-openapi/runtime/middleware"
)

// DenyHandlerFunc turns a function with the right signature into a deny handler
type DenyHandlerFunc func(DenyParams, interface{}) middleware.Responder

// Handle executing the request and returning a response
func (fn DenyHandlerFunc) Handle(params DenyParams, principal interface{}) middleware.Responder {
	return fn(params, principal)
}

// DenyHandler interface for that can handle valid deny params
type DenyHandler interface {
	Handle(DenyParams, interface{}) middleware.Responder
}

// NewDeny creates a new http.Handler for the deny operation
func NewDeny(ctx *middleware.Context, handler DenyHandler) *Deny {
	return &Deny{Context: ctx, Handler: handler}
}

/* Deny swagger:route POST /bids/deny deny

Refuse sessions to new connections using tokens with the bid(s) (booking ids), and disconnect any current sessions immediately.

Refuse sessions to new connections using tokens with the bid (booking id), and disconnect any current sessions immediately. The exp term is the unix time in UTC when the booking finishes (i.e. the earliest time it is safe to remove the bid from the deny list)

*/
type Deny struct {
	Context *middleware.Context
	Handler DenyHandler
}

func (o *Deny) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
	route, rCtx, _ := o.Context.RouteInfo(r)
	if rCtx != nil {
		*r = *rCtx
	}
	var Params = NewDenyParams()
	uprinc, aCtx, err := o.Context.Authorize(r, route)
	if err != nil {
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}
	if aCtx != nil {
		*r = *aCtx
	}
	var principal interface{}
	if uprinc != nil {
		principal = uprinc.(interface{}) // this is really a interface{}, I promise
	}

	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
		o.Context.Respond(rw, r, route.Produces, route, err)
		return
	}

	res := o.Handler.Handle(Params, principal) // actually handle the request
	o.Context.Respond(rw, r, route.Produces, route, res)

}
